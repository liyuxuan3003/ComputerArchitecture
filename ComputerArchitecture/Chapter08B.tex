\section{缓存的实现方式}

缓存的结构可以用以下的描述来概括：整个缓存会被划分为$S$个组（Set），每个组包含$N$个块（Block），也称为$N$个通道或$N$路（Way），每个块包含$B$个字（Word）。因此，如果缓存的容量记为$C$，则显然有$C=S\cdot N\cdot B$成立。这里要澄清的是，通道数和（一个组中）块的数量是同一回事，通道中只有一个块！请始终记住当我们称一个缓存有$N$个通道或$N$路时就是在说一个组中有$N$个块。总结起来，可以用“$S$组$N$路且块大小为$B$”来描述一个缓存。
\begin{itemize}
    \item 组的数量$S$反映了缓存映射（从大至小）的取模运算的模数，这是缓存的基础。
    \item 路的数量$N$反映了缓存的时间局域性，将映射至同一组的数据缓存至不同块上。
    \item 块的大小$B$反映了缓存的空间局域性，将目标数据和邻近数据一起缓存。
\end{itemize}

\begin{Figure}[缓存的映射关系]
    \includegraphics[scale=0.7]{CacheMemoryMap.fig.pdf}
\end{Figure}

作为一个数据的参考，对于一个容量为$C=\qnum{64}{\Kibi}$的缓存，典型的通道数是$N=\qnum{2}{}$，典型的块大小是$B=\qnum{64}{}$。简洁起见，本节将考虑一个容量只有$C=8$的缓存，并依次分析三种情况
\begin{itemize}
    \item $S=8$，$N=1$，$B=1$，研究缓存映射的取模运算。
    \item $S=4$，$N=2$，$B=1$，研究缓存如何通过路的数量$N$利用时间局域性。
    \item $S=2$，$N=1$，$B=4$，研究缓存如何通过块的大小$B$利用空间局域性。
\end{itemize}

\subsection{缓存与取模运算}

缓存通过取模运算实现空间映射，如\cref{fig:缓存的映射关系}所示，对于容量$C=8$的缓存空间，我们可以将其分为$S=8$个组，每组存储$1$个数据，依次称为Set \code{000}、Set \code{001}、$\cdots$、Set \code{111}。而对于内存地址，除去因数据占用四个字节带来的最低$2$位固定\code{00}的Byte Offset后，根据次低$3$位映射至Set编号相同的缓存组中，如\code{00...000 00100}、\code{00...001 00100}、\code{11...111 00100}都可以映射到\code{001}的缓存处。这样一来，如果重复读取同一个数据，读取速度就可以大大加快！

缓存是如何通过地址判断正在读取的数据是否存在于缓存中呢？如\cref{fig:缓存与取模运算}所示，内存地址从低到高被划分为Byte Offset、Set、Tag三个字段，缓存除了存储数据，还要存储数据对应地址的Tag字段，作为区分存储的是映射到该位置的哪一数据的标签。读取时，首先根据读取地址的Set字段索引出缓存中的对应行，随后比较读取地址和缓存中的Tag字段，若一致，说明这是一次Cache Hit，反之，说明这是一次Cache Miss，需要进一步去内存中读取数据。另外，缓存还需要维护一个额外的V字段，用来标识该Set为空，这在刚初始化后是有用的。

\begin{Figure}[缓存与取模运算]
    \includegraphics[scale=0.7]{CacheSet.fig.pdf}
\end{Figure}

\subsection{缓存与时间局域性}

缓存如何实现时间局域性？试想，若交替读取两个Set一致的数据，那么缓存将无法发挥任何作用！如\cref{fig:缓存与时间局域性}所示，可以只使用$S=4$组，每组中设置$W=2$路，每路中存储$B=1$个数据。同一组中存在多路的好处是，同一个Set可以容纳多个不同Tag的数据，从而使最近使用的数据能停留更长时间！我们通过一个简单的U字段来判断哪一路应该优先被覆盖，例如这里刚刚位于Way \code{1}上的数据，那么就要将U设置为\code{0}以表示接下来应优先覆盖Way \code{0}上的数据。不过，值得注意的是，如果存在更多路，一般仍然会使用$1$位的U字段！我们会将所有的路分为两个部分，用U标识最近没有使用的那一部分，当需要缓存新数据时，随机在其中选择一路进行覆盖。这种方法相对简单，且在绝大多数情况下足矣提供足够的时间局域性。

\begin{Figure}[缓存与时间局域性]
    \includegraphics[scale=0.7]{CacheWay.fig.pdf}
\end{Figure}

\subsection{缓存与空间局域性}

缓存如何实现空间局域性？试想，若连续读取数据，比较高效的方法是将其邻近的数据一并读取回来。如\cref{fig:缓存与空间局域性}所示，可以只使用$S=2$组，简洁起见，每组中仅设置$W=1$路，但现在每路中可以存储$B=4$个数据。在Set之外新增了一个Block字段，当读取某个数据时，会同时将邻近的Block为\code{00}、\code{01}、\code{10}、\code{11}的数据读至缓存，这就增加了空间局域下的缓存命中率。

\begin{Figure}[缓存与空间局域性]
    \includegraphics[scale=0.7]{CacheBlock.fig.pdf}
\end{Figure}

然而，一个值得思考的问题是，如果访问内存的时间是一定的，那如果每次都要读取$4$个数据，是否需要消耗$4$倍的时间，使利用空间局域性的尝试变得没有意义？答案是否定的，因为存储器往往支持这样的读取模式，提供一个地址，要求其连续传输从这个地址起的一系列数据。第一个数据到达需要若干周期，但接下来每个周期都能传输一个数据，故不会增加太多负担。

空间局域性和时间局域性是可以并存的！每组中可以有若干路，每路中可以存储若干数据。

\subsection{缓存的写策略}

上述主要讨论的是缓存的读取，缓存的写入基本是类似的，但会有一点不同：当数据写入缓存后，以何种方式同步到内存中？这衍生出两种策略：写直通（Write Through）和写回（Write Back）。写直通策略意味着数据在写入缓存后也立即写入内存，这会导致写数据总是需要消耗较长时间，但是比较简单。写回策略意味着数据在写入缓存后暂时不写入内存，而是在缓存中将该数据标记为脏（Dirty Bit），当包含脏数据的缓存要被覆盖时，再将数据写回到内存中。