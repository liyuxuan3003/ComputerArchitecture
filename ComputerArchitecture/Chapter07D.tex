\section{流水线处理器}

流水线的思想和原理可以用“洗衣服”来形象解释。最初，我们使用的是一台洗烘一体机，衣服在完成清洗后会自动进行烘干，两者均需要半个小时。然而，我们注意到，清洗的半个小时烘干是闲置的，烘干的半个小时清洗是闲置的，这就是流水线能优化的空间所在。我们可以将其拆分为两台独立的洗衣机和烘干机，当有很多批衣服要清洗时，前一批衣服从洗衣机取出进入烘干机，后一批衣服就可以进入洗衣机了，同时有两批衣服在流水线上前进。这样平均下来，一批衣服完成清洗和烘干就只需要半个小时！当然，流水线的启动和结束需要额外时间。

流水线处理器的完整电路如\xref{fig:流水线RISC-V处理器}所示。它本质是将\xref{fig:单周期RISC-V处理器}的单周期处理器拆分为五个阶段，相互之间用寄存器间隔开，使得处理器能同时执行五条指令。流水线的五个阶段依次是
\begin{enumerate}
    \item 取指阶段（Fetch, IF）
    \item 译码阶段（Decode, ID）
    \item 执行阶段（Excute, EX）
    \item 存储阶段（Memory, MEM）
    \item 写回阶段（Writeback, WB）
\end{enumerate}
\begin{Figure}[流水线RISC-V处理器]
    \includegraphics[width=\linewidth]{build/Chapter07D_01.fig.pdf}
\end{Figure}

由于各个阶段内执行的是不同的指令，故在其信号后分别添加后缀\codex{F,D,E,M,W} 以示区分。

然而，流水线处理器的真正复杂之处并不在于流水线。关键是，指令和指令间是可能存在依赖关系的！若一条指令依赖于前序尚未执行完成的指令，这就会导致冒险（Hazard）的发生。冒险主要有两种类型：数据冒险（Data Hazard）是指，当前指令通过ALU计算或通过DMEM读取的数据，在后续几条指令中被立即使用，但此时数据尚未写回寄存器，从而导致后续指令读取了错误的寄存器数据。控制冒险（Control Hazard）是指，当前指令是JAL或BRANCH类型的跳转指令，尚未完成跳转决定和跳转地址的计算，从而导致后续指令被错误的顺序执行。冒险的正确识别和处理是流水线设计的关键！这也是\xref{fig:流水线RISC-V处理器}中Hazard Unit及围绕其的大量信号在做的事情。不过，在进一步详细讨论冒险之前，我们先有必要解释几处额外的修改。

第一处修改与\codex{PCSrcE} 有关。或许更明显的是，过去，产生\codex{PCSrc} 的与门和或门是位于控制单元内部的，而现在却暴露在外。这是因为，控制单元位于ID阶段，但是，产生\codex{PCSrc} 的输入之一\codex{Zero} 却要直到EX阶段才能由ALU给出，所以需要将逻辑门移动到控制单元外并置于EX阶段。我们可以看到，跳转决定\codex{PCSrcE} 和跳转地址\codex{PCTargetE} 在EX阶段产生，但却作用在IF阶段，这也是控制冒险的产生原因。在进行跳转前，已经有两条顺序执行指令错误进入了流水线。由此可见，控制冒险的处理的关键就在于从流水线中移除错误指令。

第二处修改与\codex{RdW} 有关。我们注意到，现在寄存器堆的三个输入中，前两者\codex{A1,A2} 是直接来自\codex{InstrD} 拆分出的\codex{Rs1D,Rs2D}，而\codex{A3} 却来自\codex{RdW}。这是因为寄存器堆的写回地址\codex{RdW} 必须与写回数据\codex{ResultW} 同步，若使用\codex{RdD} 接入\codex{A3}，则会导致当前指令的写会地址被写入了三条指令之前的写回数据。类似的，写回地址\codex{RdW} 和写回数据\codex{ResultW} 的WB阶段和可能使用这些数据的ID阶段相差三条指令，这就是数据冒险的产生原因。若一条指令的写回数据需要被其后紧随的三条指令读取，那么读取到的是更新前的错误数据。不过，有一个简单的技巧可以让数据冒险的范围从“后三条”降低到“后两条”，这就是将寄存器堆的时钟由\codex{CLK} 更换为\ \texttt{\ctikztextnot{CLK}}。这会导致寄存器堆的写入发生在每个周期的中间而不是结束，换言之，寄存器堆将实现“前半周期写、后半周期读”。这样一来，由于相差三条指令时，后续指令和前续指令在同一周期分别于EX阶段和WB阶段读写寄存器堆，但由于先写后读，这就不再有冲突了。

% 有关于不同类型冒险的处理，我们有三种解决途径
% \begin{itemize}
%     \item 流水线前递（Forward），适用于数据冒险，其中数据来自ALU计算结果。
%     \item 流水线停滞（Stall），适用于数据冒险，其中数据来自DMEM读取结果。
%     \item 流水线冲刷（Flush），适用于控制冒险。
% \end{itemize}
% 实际上，这三种解决途径和冒险情形的对应关系只是大致上的，

\subsection{流水线前递}
流水线前递（Forward）的引入可以解决ALU计算结果导致的数据冒险，如\xref{fig:流水线前递}所示。这类图像可以很好的表现流水线不同阶段之间的依赖关系：横向代表同一条指令在不同周期依次经过的阶段，纵向代表同一周期下不同阶段的执行内容。这里的示意程序的关键在于，第一条指令由\codex{t5,t6} 相加得到\codex{s0}，第二第三第四条指令则分别令\codex{s0} 与\codex{t1,t2,t3} 依次做不同计算得到\codex{s1,s2,s3}，其中，对\codex{s0} 的立即使用导致在第二条和第三条指令上发生了数据冒险。

通过仔细观察，我们可以发现这里的数据冒险并不是因为结果没有被及时计算出来，只不过还没来得及写回寄存器。前递的思路是，通过额外路径，将刚刚计算出的“热乎”结果送到马上需要的位置。第二条和第三条指令在ID阶段从寄存器堆读取的\codex{s0} 都是错误的，然而，至第二条和第三条指令真正用到\codex{s0} 的EX阶段所在的周期T3和T4下时，正确的\codex{s0} 已经存在于第一条指令的MEM阶段和WB阶段。因此，只要能将\codex{s0} 跨阶段前递就能解决冒险。

在\xref{fig:流水线RISC-V处理器}中，

\begin{Figure}[流水线前递]
    \includegraphics[width=\linewidth]{build/Chapter07D_02.fig.pdf}
\end{Figure}