\section{机器语言}

汇编语言便于人的阅读，然而，数字电路只能理解二进制。因此，汇编语言编写的程序需要转换为用二进制表示的机器语言。RISC-V固定使用$32$位编码一条指令。通过\cref{sec:汇编语言}的学习我们已经知道，有些指令的操作数比较简单，有些指令的操作数比较复杂，故势必会有一些指令并不需要全部$32$位的编码空间。然而，若使用可变长指令，则会显著增加处理器的复杂性。
\begin{BoxDesignPrinciple}[好设计需要好妥协]
    \centering
    Good design demands good compromises.
\end{BoxDesignPrinciple}

RISC-V为了更充分的利用32位的编码空间，做出的妥协是定义六种指令类型
\begin{itemize}
    \item R型指令（Register）：寄存器类型。操作数是\code{rs1,rs2,rd}。这类指令涵盖了所有寄存器运算指令，将\code{rs1}和\code{rs2}经过运算的结果写入\code{rd}。这是最容易理解的一类指令。
    \item I型指令（Immediate）：立即数类型。操作数是\code{imm,rs1,rd}。这类指令涵盖了所有立即数运算指令，将\code{rs1}和\code{imm}经过运算的结果写入\code{rd}。除此之外，这一类型中还包含了读取指令和跳转至寄存器并链接指令。前者是将地址\code{imm(rs1)}的数据写入\code{rd}，后者则是将\code{pc+4}写入\code{rd}并令\code{pc}跳转至\code{rs1+imm}处。因此，I型指令不仅仅是立即数运算！
    \item S型指令（Store）：存储类型。操作数是\code{imm,rs1,rs2}。这类指令涵盖了所有存储指令，将\code{rs2}的数据写入地址\code{imm(rs1)}处。应指出，I型指令和S型指令都使用了两个寄存器和一个立即数作为操作数，然而，前者为\code{rs1,rd}，后者为\code{rs1,rs2}。这是因为我们会用\code{rs}和\code{rd}来区分“源寄存器”和“目标寄存器”，前者只需要读，后者只需要写。
    \item B型指令（Branch）：分支类型。操作数是\code{imm,rs1,rs2}。这类指令覆盖了所有条件跳转指令，当\code{rs1,rs2}的数据满足这一指令的跳转条件时，令\code{pc}跳转至\code{pc+imm}处。
    \item J型指令（Jump）：跳转类型。操作数是\code{imm,rd}。这类指令仅有跳转并链接指令，其会将\code{pc+4}写入\code{rd}中并令\code{pc}跳转至\code{pc+imm}处。需要特别强调的是，尽管称为Jump，跳转并链接（\code{jal}）是唯一的J型指令！跳转至寄存器并链接（\code{jalr}）是一条I型指令。
    \item U型指令（Upper Immediate）：高位立即数类型。操作数是\code{imm,rd}。前述指令的立即数都只用了$12$位编码，故势必需要有一类指令能通过某种方式来操作立即数的高$20$位。
\end{itemize}

这六种指令类型的编码结构如\cref{fig:RISC-V指令类型}所示，其中要说明的三点是：首先，I型指令中，由于立即数位移涉及的立即数只需要$5$位（因为最大有意义的位移位数是$2^5=32$，更多没有实际意义了），故有必要分出I1型和I2型两个亚型用以区分。其次，有时我们会称RISC-V的指令类型是四种，这是指：R型指令、I型指令、S/B型指令、U/J型指令。其中，后两者使用合称的原因是，S型和B型中立即数都用12位编码，U型和J型中立即数都用20位编码，区别仅在于这些位数的编码会被分别映射到不同的立即数位上。例如，同样是用$12$位来编码立即数，S型指令是\code{imm[11:0]}，B型指令是\code{imm[12:1]}，这是根据指令对于立即数的实际用途确定的。最后，我们可能注意到立即数的编码有些混乱，有些被拆分为两端，有些有各别位很突兀的插入到别的地方。这是多方面妥协的结果：将立即数分段是为了保证\code{rs1,rs2,rd}等字段的位置在指令中保持不变。将立即数的各别位移动，是为了保证不同类型的指令间，能有尽可能多的立即数位是重合的（观察\cref{fig:RISC-V指令类型}每一行顶部的红色数字），减小硬件实现的开销。

\begin{Figure}[RISC-V指令类型]
    \includegraphics[scale=0.8]{Chapter06B_01.fig.pdf}
\end{Figure}

上述都在讨论指令的操作数，我们还需要一些字段来编码指令本身，有三个部分
\begin{itemize}
    \item \code{opcode}，共$7$位，所有指令有该字段。
    \item \code{funct3}，共$3$位，部分指令有该字段。
    \item \code{funct7}，共$7$位，仅有寄存器算数指令和立即数位移指令有该字段。
\end{itemize}

RISC-V编码指令的这三个字段\code{opcode,funct3,funct7}有很大冗余，扩展潜力很强。

\subsection{R型指令}

R型指令的编码结构、编码字段、包含的指令如\cref{fig:R型指令的编码}所示。
\begin{Figure}[R型指令的编码]
    \includegraphics[scale=0.8]{Chapter06B_02.fig.pdf}
\end{Figure}

\cref{tab:R型指令的列表}展示了全部的R型指令。R型指令只有一种\code{opcode}为OP(51)。通常而言，我们会通过字段\code{opcode}区分最基本的指令类型。例如，这里\code{opcode}的代号OP就是指“运算指令”。

R型指令都是寄存器的运算指令，大致可以分为四类：算数运算、位移运算、逻辑运算、比较运算。R型指令中每条指令间主要用\code{funct3}区分，但有两组指令，算数指令的\code{add,sub}和右移指令\code{srl,sra}具有相同的\code{funct3}，通过\code{funct7}分别取\code{0000000,0100000}来区分“加/减”以及“逻辑右移/算数右移”。这里\code{slt,sltu}的比较指令是之前没有介绍过的，这两条指令会分别将\code{rs1,rs2}视为有符号数和无符号数进行小于比较，并将结果写入\code{rd}。不过，值得注意的是，仅有这两条指令并不能完备的表达所有比较运算，尚不清楚专门引入其的目的所在。
\begin{Table}[R型指令的列表]!!
    \begin{tblr}
    {
        colspec={X[12,l]X[24,l]cccc},
        cell{1}{4-6}={preto=\ttfamily},
        cell{even[2-Z]}{1-Z}={preto=\ttfamily},
        cell{odd[2-Z]}{1}={c=2}{halign=l},
        cell{odd[2-Z]}{3}={c=4}{halign=r},
        hline{even[3-Y]}={\linesplit},
    }
        指令&用途&类型&opcode&f3&f7\\
        add rd,rs1,rs2&rd=rs1+rs2&R&0110011&000&0000000\\*
        Add&&寄存器加法&&&\\
        sub rd,rs1,rs2&rd=rs1-rs2&R&0110011&000&0100000\\*
        Sub&&寄存器减法&&&\\
        sll rd,rs1,rs2&rd=rs1<<rs2[4:0]&R&0110011&001&0000000\\*
        Shift Left Logical&&寄存器逻辑左移&&&\\
        srl rd,rs1,rs2&rd=rs1>>rs2[4:0]&R&0110011&101&0000000\\*
        Shift Right Logical&&寄存器逻辑右移&&&\\
        sra rd,rs1,rs2&rd=rs1>>>rs2[4:0]&R&0110011&101&0100000\\*
        Shift Right Arithmetic&&寄存器算数右移&&&\\
        xor rd,rs1,rs2&rd=rs1\^{}rs2&R&0110011&100&0000000\\*
        Xor&&寄存器异或&&&\\
        or rd,rs1,rs2&rd=rs1|rs2&R&0110011&110&0000000\\*
        Or&&寄存器或&&&\\
        and rd,rs1,rs2&rd=rs1\&rs2&R&0110011&111&0000000\\*
        And&&寄存器与&&&\\
        slt rd,rs1,rs2&rd=(rs1<rs2)&R&0110011&010&0000000\\*
        Set Less Than&&寄存器当小于（有符号）时赋值&&&\\
        sltu rd,rs1,rs2&rd=(rs1<rs2)&R&0110011&011&0000000\\*
        Set Less Than Unsigned&&寄存器当小于（无符号）时赋值&&&\\
    \end{tblr}
\end{Table}

\subsection{I型指令}
I型指令的编码结构、编码字段、包含的指令如\cref{fig:I型指令的编码}所示。

\cref{tab:I型指令的列表}展示了全部的I型指令。I型指令有I1和I2两个变种。I1型是主要的，使用了$12$位的立即数。I2型则是对于立即数位移的一个变种，由于位移只需要$5$位立即数，多余的$7$位用来编码\code{funct7}。I型指令有OP-IMM(19)、LOAD(3)、JALR(103)三种不同的\code{opcode}，它们分别对应立即数运算指令、读取指令、跳转至寄存器并链接指令（该类只包含一条\code{jalr}）。

\cref{tab:I型指令的列表}中在说明用途的伪代码中，有些符号需要解释一下
\begin{itemize}
    \item \code{SE()}表示SignExtend即有符号扩展至$32$位数。
    \item \code{ZE()}表示ZeroExtend即无符号扩展至$32$位数。
    \item \code{[Address]}表示存储器中地址为\code{Address}处的$32$位数据。
\end{itemize}

我们可以注意到，立即数采用的都是有符号扩展，实际上，这一点对于所有RISC-V指令的立即数都是成立的！当然，在I2型指令用于表示位移的$5$位立即数是无符号的，然而由于进行位移运算时，其只会考察最低的$5$位，故这里如何扩展是无关紧要的，不妨碍结论的成立。
\begin{Figure}[I型指令的编码]
    \figuresub[I1型指令的编码]{\includegraphics[scale=0.8]{Chapter06B_03.fig.pdf}}

    \figuresub[I2型指令的编码]{\includegraphics[scale=0.8]{Chapter06B_04.fig.pdf}}
\end{Figure}

除此之外，\cref{tab:I型指令的列表}中有关读取指令的伪代码表示仅在逻辑上是正确的，例如，可以考察字节读取指令\code{lb rd,imm(rs1)}，其用途被记为\code{rd=SE([rs1+SE(imm)][7:0])}，不妨假设\code{rs1=0}而\code{imm=5}，存储器的地址看起来是\code{0123,4567,89AB,...}，按照这一伪代码，我们将读取\code{5678}这个字，并从中获得最低的那一字节即\code{5}处的数据。然而，存储器往往并不能支持这样非对齐的字访问，实现上正确的做法应该是先设法读取\code{4567}的字，再从其中读取出\code{5}这个字节。
\begin{Table}[I型指令的列表]!!
    \begin{tblr}
    {
        colspec={X[12,l]X[24,l]cccc},
        cell{1}{4-6}={preto=\ttfamily},
        cell{even[2-Z]}{1-Z}={preto=\ttfamily},
        cell{odd[2-Z]}{1}={c=2}{halign=l},
        cell{odd[2-Z]}{3}={c=4}{halign=r},
        hline{even[3-Y]}={\linesplit},
    }
        指令&用途&类型&opcode&f3&f7\\
        addi rd,rs1,imm&rd=rs1+SE(imm)&I1&0010011&000&-------\\*
        Add Immediate&&立即数加法&&&\\
        slli rd,rs1,imm&rd=rs1<<imm&I2&0010011&001&0000000\\*
        Shift Left Logical Immediate&&立即数逻辑左移&&&\\
        srli rd,rs1,imm&rd=rs1>>imm&I2&0010011&101&0000000\\*
        Shift Right Logical Immediate&&立即数逻辑右移&&&\\
        srai rd,rs1,imm&rd=rs1>>>imm&I2&0010011&101&0100000\\*
        Shift Right Arithmetic Immediate&&立即数算数右移&&&\\
        xori rd,rs1,imm&rd=rs1\^{}SE(imm)&I1&0110011&100&-------\\*
        Xor Immediate&&立即数异或&&&\\
        ori rd,rs1,imm&rd=rs1|SE(imm)&I1&0110011&110&-------\\*
        Or Immediate&&立即数或&&&\\
        andi rd,rs1,imm&rd=rs1\&SE(imm)&I1&0110011&111&-------\\*
        And Immediate&&立即数与&&&\\
        slti rd,rs1,imm&rd=(rs1<SE(imm))&I1&0110011&010&-------\\*
        Set Less Than Immediate&&立即数当小于（有符号）时赋值&&&\\
        sltiu rd,rs1,imm&rd=(rs1<SE(imm))&I1&0110011&011&-------\\*
        Set Less Than Immediate Unsigned&&立即数当小于（无符号）时赋值&&&\\
        lb rd,imm(rs1)&rd=SE([rs1+SE(imm)][7:0])&I1&0000011&000&-------\\*
        Load Byte&&读取字节&&&\\
        lh rd,imm(rs1)&rd=SE([rs1+SE(imm)][15:0])&I1&0000011&001&-------\\*
        Load Half&&读取半字&&&\\
        lw rd,imm(rs1)&rd=[rs1+SE(imm)]&I1&0000011&010&-------\\*
        Load Word&&读取字&&&\\
        lbu rd,imm(rs1)&rd=ZE([rs1+SE(imm)][7:0])&I1&0000011&100&-------\\*
        Load Byte Unsigned&&读取无符号字节&&&\\
        lhu rd,imm(rs1)&rd=ZE([rs1+SE(imm)][15:0])&I1&0000011&101&-------\\*
        Load Half Unsigned&&读取无符号半字&&&\\
        jalr rd,rs1,imm&rd=pc+4, pc=rs1+SE(imm)&I1&1100111&000&-------\\*
        Jump and Link Register&&跳转至寄存器并链接&&&\\
    \end{tblr}
\end{Table}

\subsection{S/B型指令}
S型指令和B型指令的编码结构、编码字段、包含的指令如\cref{fig:S型指令的编码}和\cref{fig:B型指令的编码}所示。

\cref{tab:S/B型指令的列表}展示了全部的S/B型指令，S型指令中只包含STORE(35)一种\code{opcode}，代表存储指令，B型指令中只包含BRANCH(99)一种\code{opcode}，代表分支指令。这里需要重点解释的是分支指令。首先，在汇编语言中，分支指令都是以标签\code{lab}的形式指定跳转位置的，然而，将汇编代码转换为机器代码时，这些标签对应的指令地址会被转换为相对于当前指令地址的一个立即数偏移。其次，B型指令的立即数编码的是\code{imm[12:1]}，这实际上代表了一个$13$位的立即数，其中最低位\code{imm[0]}恒定为\code{0}。这一设计的原因是，RISC-V指令都是$32$位的，即便考虑到RISC-V的$16$位的压缩指令的扩展，任何一条指令的地址至少都是$2$的倍数（通常是$4$的倍数），使用最低位恒为\code{0}的$13$位立即数相较$12$位立即数可以获得更大的跳转范围。
\begin{Figure}[S型指令的编码]
    \includegraphics[scale=0.8]{Chapter06B_05.fig.pdf}
\end{Figure}

\begin{Figure}[B型指令的编码]
    \includegraphics[scale=0.8]{Chapter06B_06.fig.pdf}
\end{Figure}

\begin{Table}[S/B型指令的列表]!!
    \begin{tblr}
    {
        colspec={X[12,l]X[24,l]cccc},
        cell{1}{4-6}={preto=\ttfamily},
        cell{even[2-Z]}{1-Z}={preto=\ttfamily},
        cell{odd[2-Z]}{1}={c=2}{halign=l},
        cell{odd[2-Z]}{3}={c=4}{halign=r},
        hline{even[3-Y]}={\linesplit},
    }
        指令&用途&类型&opcode&f3&f7\\
        sb rs2,imm(rs1)&[rs1+SE(imm)][7:0]=rs2[7:0]&S&0100011&000&-------\\*
        Store Byte&&存储字节&&&\\
        sh rs2,imm(rs1)&[rs1+SE(imm)][15:0]=rs2[15:0]&S&0100011&001&-------\\*
        Store Half&&存储半字&&&\\
        sw rs2,imm(rs1)&[rs1+SE(imm)]=rs2&S&0100011&010&-------\\*
        Store Word&&存储字&&&\\
        beq rs1,rs2,lab&if(rs1==rs2) pc+=SE(\{imm,1'b0\})&B&1100011&000&-------\\*
        Branch If Equal&&若相等则跳转&&&\\
        bne rs1,rs2,lab&if(rs1!=rs2) pc+=SE(\{imm,1'b0\})&B&1100011&001&-------\\*
        Branch If Not Equal&&若不等则跳转&&&\\
        blt rs1,rs2,lab&if(rs1< rs2) pc+=SE(\{imm,1'b0\})&B&1100011&100&-------\\*
        Branch If Less Than&&若小于（有符号）则跳转&&&\\
        bltu rs1,rs2,lab&if(rs1< rs2) pc+=SE(\{imm,1'b0\})&B&1100011&110&-------\\*
        Branch If Less Than Unsigned&&若小于（无符号）则跳转&&&\\
        bge rs1,rs2,lab&if(rs1>=rs2) pc+=SE(\{imm,1'b0\})&B&1100011&101&-------\\*
        Branch If Greater Than or Equal&&若大等（有符号）则跳转&&&\\
        bgeu rs1,rs2,lab&if(rs1>=rs2) pc+=SE(\{imm,1'b0\})&B&1100011&111&-------\\*
        Branch If Greater Than or Equal Unsigned&&若大等（无符号）则跳转&&&\\
    \end{tblr}
\end{Table}

\subsection{U/J型指令}

U型指令和J型指令的编码结构、编码字段、包含的指令如\cref{fig:U型指令的编码}和\cref{fig:J型指令的编码}所示。
\begin{Figure}[J型指令的编码]
    \includegraphics[scale=0.8]{Chapter06B_07.fig.pdf}
\end{Figure}

\begin{Figure}[U型指令的编码]
    \includegraphics[scale=0.8]{Chapter06B_08.fig.pdf}
\end{Figure}

\cref{tab:S/B型指令的列表}展示了全部的U/J型指令，这两类指令的数量都很有限，J型指令仅有\code{jal}一条，U型指令仅有\code{lui,auipc}两条。同时，由于U/J型指令都使用了$20$位编码立即数，因此其中能用于编码指令本身的字段就只有\code{opcode}了（过去主要用\code{funct3}区分），所以这里都是一条指令对应一个\code{opcode}，依次是JAL(111)、LUI(55)、AUIPC(23)，分别代表其同名指令。

U/J型都用$20$位编码的立即数，两者的处理各不相同
\begin{itemize}
    \item J型中使用$21$位立即数\code{imm[20:1]}，同样是出于指令地址至少是$2$的倍数的考虑。
    \item U型中使用$32$位立即数\code{imm[31:12]}，其中低$12$位直接填\code{0}，因为U型指令本身就是用于加载高$20$位。通过联用\code{lui,addi}就可以将任意$32$位数加载到一个寄存器中。
\end{itemize}

这里我们总结一下与\code{pc}相关的指令
\begin{itemize}
    \item \code{jal rd,lab}，属于J型指令，也是唯一的J型指令，立即数为$21$位。
    \item \code{jalr rd,rs1,imm}，属于I型指令，立即数为$12$位。注意，这与以当前地址为基准偏移的B型指令和J型指令分别使用最低位恒\code{0}的$13$位立即数和$21$位立即数不同。故编码\code{jalr}中的立即数时，我们不需要将地址偏移除以$2$！这一设计也可能是多方面考虑的结果。首先，\code{jalr}的跳转是以寄存器为基础偏转的，灵活性已经很强了，纠结这$1$位带来的范围减小意义不大。其次，\code{jalr}的立即数结构受限于I型指令本身，若需要将其改为$13$位，需要再从I型指令分出一个类型，这无疑会增加硬件实现的复杂些。
    \item \code{auipc rd,imm}，属于U型指令，立即数为$32$位。这一指令也是过去没有出现过的，其并不是一条跳转指令，而是将当前\code{pc}简单的与一个高位立即数相加并保存到\code{rd}中。该指令可以用于获得当前\code{pc}，另外，通过\code{auipc,jalr}的联用，实现$32$位偏移的大跳。
\end{itemize}

\begin{Table}[U/J型指令的列表]!!
    \begin{tblr}
    {
        colspec={X[12,l]X[24,l]cccc},
        cell{1}{4-6}={preto=\ttfamily},
        cell{even[2-Z]}{1-Z}={preto=\ttfamily},
        cell{odd[2-Z]}{1}={c=2}{halign=l},
        cell{odd[2-Z]}{3}={c=4}{halign=r},
        hline{even[3-Y]}={\linesplit},
    }
        指令&用途&类型&opcode&f3&f7\\
        jal rd,lab&rd=pc+4, pc+=SE(\{imm,1'b0\})&J&1101111&---&-------\\*
        Jump and Link&&跳转并链接&&&\\
        lui rd,imm&rd=\{imm,12'b0\}&U&0110111&---&-------\\*
        Load Upper Immediate&&加载高位立即数&&&\\
        auipc rd,imm&rd=pc+\{imm,12'b0\}&U&0010111&---&-------\\*
        Add Upper Immediate to PC&&将当前地址与高位立即数相加&&&\\
    \end{tblr}
\end{Table}